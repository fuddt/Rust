---

marp: true

paginate: true

math: true

---


# <center>構造体について2ーメソッド・関連関数・トレイト

---

前回構造体について学びました.

構造体使うと、情報の整理がしやすくなる！だけじゃなく、RustではPythonやC＃であるようなクラスがないので、構造体にメソッドや関連関数を定義することで、クラスのような使い方をします。

---

# メソッドを定義する
構造体にメソッドを定義するには、`impl`ブロックを使用します。
`impl`ブロック内で、構造体に関連する関数を定義できます。

```rust
struct Horse {
    name: String,
    age: u32,
    color: String,
}
impl Horse {
    // メソッドの定義
    fn show_info(&self) {
        println!("Name: {}", self.name);
        println!("Age: {}", self.age);
        println!("Color: {}", self.color);
    }
}
```

---
# メソッドの呼び出し
メソッドは、構造体のインスタンスに対して呼び出すことができます。インスタンスとは、構造体の具体的な値を入れたもの。下記の場合は`horse`です。


```rust
fn main() {
    let horse = Horse {
        name: String::from("メイショウタバル"),
        age: 4,
        color: String::from("黒"),
    };

    // メソッドの呼び出し
    horse.show_info();
}
```
---

## selfってなに？
`self`は、メソッドが呼び出されたインスタンス自身を指します。メソッド内でインスタンスのフィールドにアクセスするために使用されます。

```rust
impl Horse {
    fn show_info(&self) {
        println!("Name: {}", self.name);
        println!("Age: {}", self.age);
        println!("Color: {}", self.color);
    }
}
```

---


# メソッド？関数でなくて？

「関数」と「メソッド」の違いは、メソッドは特定の構造体のインスタンスに関連付けられている点です。メソッドは、`self`引数を持ち、インスタンスのデータにアクセスできます。
関数は、特定の構造体に関連付けられていないため独立した存在です。

メソッドと言われたら、何かの構造体に関連付けられた関数
関数と言われたら、何の構造体とも関連付けられていない関数

---
# 関連関数
関連関数は、構造体に関連付けられた関数で、インスタンスを必要としない関数です。
関数は関数だけど、ある構造体と紐づけておいた方が管理しやすいときに使うといいと思います。

```rust
impl Horse {
    // 関連関数の定義
    fn run() {
        println!("horse is running!");
    }
}
```

runを構造体と紐付けなくてもいいけど、紐付けておくと馬の動作に関する関数だとわかりやすいし、Horseにつけておいた方が管理しやすいよね、という感じです。

---

# 関連関数の呼び出し
関連関数は、構造体名を使って呼び出します。インスタンスを作成する必要はありません。

```rust
fn main() {
    // 関連関数の呼び出し
    Horse::run();
}
```
---

# まとめ
関数: 独立した関数で、特定の構造体に関連付けられていない。
メソッド: 特定の構造体のインスタンスに関連付けられた関数で、`self`引数を持つ。
関連関数: 構造体に関連付けられた関数で、インスタンスを必要としない。

---

# トレイト
トレイトは、Rustのオブジェクト指向プログラミングの重要な概念で、特定の機能を持つことを定義するためのものです。
トレイトは、他の型に対して共通の振る舞を定義するために使用されます。

例えばHorse、Cat、Dog、Bardという構造体があったとして、これらの構造体には鳴き方は異なれど、みんな「鳴く」という共通する振る舞いをして欲しいときにトレイトを使います。

トレイトを定義するには、`trait`キーワードを使用します。トレイト内でメソッドのシグネチャを定義し、構造体に実装します。

---


```rust
trait Animal {
    fn make_sound(&self); //Animalトレイトのメソッド　
    // 鳴き方は各動物ごとに異なるから具体的なことはわからない
}

struct Horse;
struct Cat;

impl Animal for Horse {
    fn make_sound(&self) {
        println!("ヒヒーン");
    }
}
impl Animal for Cat {
    fn make_sound(&self) {
        println!("ニャー");
    }
}
```
---

これだけだと何のメリットがあるんだ！って話なので、このトレイトがあることで便利になる続きを作っていきます。

ある関数が構造体を引数にとって、その構造体のmake_soundメソッドを呼び出すとします。

```rust
fn animal_sound(animal: &impl Animal) {
    println!("この動物の鳴き声は:");
    animal.make_sound();
    println!("です！！。");
}
```

---
このとき引数の型をトレイトで指定することで、Animalトレイトを実装したどの構造体でもこの関数を使うことができます。

```rust
fn main() {
    let horse = Horse;
    let cat = Cat;
    animal_sound(&horse); // Horseの鳴き声を出力
    animal_sound(&cat); // Catの鳴き声を出力
}
```

※ちなみに何もフィールドがない構造体は、`struct Horse;`のように書くことができます。ユニット構造体と呼ばれます。フィールドはないけど、構造体としての型は存在させたいときに使います。

---
もしもトレイトがなかったら、以下のように関数を定義しなければいけません。

```rust
fn animal_sound_horse(horse: &Horse) {
    println!("この馬の鳴き声は:");
    horse.make_sound();
    println!("です！！。");
}
fn animal_sound_cat(cat: &Cat) {
    println!("この猫の鳴き声は:");
    cat.make_sound();
    println!("です！！。");
}
```
この場合、HorseとCatの鳴き声を出力する関数が別々に必要になり、コードの重複が発生します。

それだったら、トレイトを使って共通の振る舞いを定義しておけば、どの動物でも同じ関数を使えるので、コードの重複を避けることができます。

---
# トレイトを関数の引数として指定する場合

引数でトレイトを指定する場合、`&impl Trait`の形式で書きます。これにより、トレイトを実装した任意の型を受け取ることができます。

```rust
fn animal_sound(animal: &impl Animal) {
    println!("この動物の鳴き声は:");
    animal.make_sound();
    println!("です！！。");
}
```

animal_sound関数は、Animalトレイトを実装した任意の型しか受け取らない作りになるため、Animalの他にHuman構造体などがあった場合にanimal_soundにHumanを渡すことが発生しないのは安全性の高い設計！ってことで最初っからトレイトを使うことを意識するのは難しいかもですが、作っている途中で「あれ？共通化できるな」と思ったらトレイトを使うといいです。

